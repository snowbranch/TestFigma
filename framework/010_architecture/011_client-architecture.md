# 客户端架构设计

## 概述

客户端架构基于 React 视图层、Reflex 状态管理和 Flamework 依赖注入构建，采用分层架构设计，实现关注点分离和高内聚低耦合。

## 分层架构

```
┌─────────────────────────────────────┐
│          表现层 (View)              │  React 组件、UI 逻辑、用户交互
├─────────────────────────────────────┤
│         控制器层 (Controller)        │  业务逻辑协调、服务调用
├─────────────────────────────────────┤
│          网络层 (Network)           │  API 客户端、数据同步
├─────────────────────────────────────┤
│          数据层 (DataProvider)      │  客户端状态管理 (Reflex)
└─────────────────────────────────────┘
```

### 数据流

遵循单向数据流模式：
- 用户交互 → React 组件 → dispatch(action) → Store → View 更新
- 表现层通过 hooks（useSelector/useDispatch）与 Store 交互
- 控制器层处理副作用和复杂业务逻辑
- 网络层负责与服务端通信

## 核心组件

### 1. 表现层（View Layer）

**React 组件体系**
- 功能模块（modules/）：完整的业务功能界面
- 通用组件（common/）：可复用的 UI 组件
- 自定义 Hooks：封装状态逻辑和副作用

**设计原则**
- 组件单一职责
- Props 接口清晰
- 避免过度嵌套
- 合理拆分大组件

### 2. 控制器层（Controller Layer）

**职责**
- 处理复杂业务逻辑
- 协调多个服务调用
- 管理副作用（导航、通知等）
- 初始化和生命周期管理

**特点**
- 使用 Flamework 依赖注入
- 单例模式保证全局唯一
- 实现生命周期接口（OnStart、OnInit 等）

### 3. 网络层（Network Layer）

**API 客户端设计**
- 类 REST 风格的 API 接口
- 统一的请求/响应格式
- 端到端类型安全
- 自动错误处理和重试

**通信模式**
- Request/Response：同步请求模式
- Remote Events：异步事件通知
- State Sync：状态自动同步

### 4. 数据层（DataProvider Layer）

**目前仅有 store 作为数据提供者**

**状态分类**
- UI 状态：界面相关的临时状态
- 缓存状态：API 响应缓存
- 游戏状态：游戏逻辑相关状态
- 共享状态：与服务端同步的状态

**状态管理原则**
- 单一数据源
- 不可变更新
- 派生状态使用选择器
- 异步操作在控制器层

## 目录结构

```
client/
├── api/             # API 封装
├── controllers/     # 控制器：业务逻辑协调
├── modules/         # UI 模块：完整功能界面
├── common/          # 通用组件和工具
│   ├── components/  # 基础 UI 组件
│   ├── hooks/       # 自定义 Hooks
│   └── providers/   # Context Providers
├── store/           # 客户端状态管理
├── network/         # 网络通信
└── utils/           # 客户端工具
```

## 关键设计模式

### 1. 依赖注入
- 控制器通过构造函数注入依赖
- 服务定位器模式获取单例服务
- 生命周期由框架统一管理

### 2. 观察者模式
- React 组件通过 hooks 订阅状态变化
- 控制器通过事件系统解耦通信
- Store 中间件实现横切关注点

### 3. 适配器模式
- API 客户端适配不同的后端接口
- 网络层抽象底层通信细节
- 统一的错误处理机制

## 性能优化策略

### 1. 渲染优化
- React.memo 减少不必要的重渲染
- useMemo/useCallback 优化计算和回调
- 虚拟列表处理大量数据
- 懒加载非关键组件

### 2. 状态优化
- 选择器缓存计算结果
- 状态规范化避免冗余
- 批量更新减少渲染次数
- 合理的状态粒度设计

### 3. 网络优化
- 请求去重和缓存
- 批量请求合并
- 乐观更新提升响应速度
- 失败重试和降级策略

## 开发规范

### 1. 组件开发
- 使用函数组件和 Hooks
- Props 类型定义完整
- 组件职责单一明确
- 适当的组件拆分粒度

### 2. 状态管理
- 最小化状态原则
- 避免状态冗余
- 合理使用本地状态
- 派生状态使用选择器

### 3. 错误处理
- Error Boundary 捕获渲染错误
- API 错误统一处理
- 用户友好的错误提示
- 错误日志和监控

## 测试策略

- 组件单元测试：测试独立组件行为
- Hook 测试：测试自定义 Hook 逻辑
- 集成测试：测试组件间交互
- 端到端测试：测试完整用户流程

## 扩展机制

- 插件化的功能模块
- 可配置的主题系统
- 灵活的路由配置
- 可扩展的状态中间件

通过这种分层架构设计，客户端实现了清晰的职责划分、良好的可维护性和优秀的开发体验。